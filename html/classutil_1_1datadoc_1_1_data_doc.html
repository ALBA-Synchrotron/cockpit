<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>OMX Cockpit: util.datadoc.DataDoc Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OMX Cockpit
   &#160;<span id="projectnumber">.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>util</b></li><li class="navelem"><b>datadoc</b></li><li class="navelem"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html">DataDoc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classutil_1_1datadoc_1_1_data_doc-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">util.datadoc.DataDoc Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classutil_1_1datadoc_1_1_data_doc.html" title="The DataDoc class is, broadly, a wrapper around the Mrc module.">DataDoc</a> class is, broadly, a wrapper around the <a class="el" href="namespaceutil_1_1_mrc.html">Mrc</a> module.  
 <a href="classutil_1_1datadoc_1_1_data_doc.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a93299839c04fb9c720d8fb1994212ea4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a93299839c04fb9c720d8fb1994212ea4">__init__</a></td></tr>
<tr class="memdesc:a93299839c04fb9c720d8fb1994212ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate the object.  <a href="#a93299839c04fb9c720d8fb1994212ea4"></a><br/></td></tr>
<tr class="memitem:a591da65bfccb09e8ed98ffebccae2e2b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a591da65bfccb09e8ed98ffebccae2e2b">getImageArray</a></td></tr>
<tr class="memdesc:a591da65bfccb09e8ed98ffebccae2e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the loaded MRC image data into a 5D array of pixel data in WTZYX order.  <a href="#a591da65bfccb09e8ed98ffebccae2e2b"></a><br/></td></tr>
<tr class="memitem:a40a200657dd2bd774b38ce8a085073e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a40a200657dd2bd774b38ce8a085073e9">takeSlice</a></td></tr>
<tr class="memdesc:a40a200657dd2bd774b38ce8a085073e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passthrough to takeSliceFromData, using our normal array.  <a href="#a40a200657dd2bd774b38ce8a085073e9"></a><br/></td></tr>
<tr class="memitem:a844bbc2df033926de9f10ec34b5660a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a844bbc2df033926de9f10ec34b5660a7">takeProjectedSlice</a></td></tr>
<tr class="memdesc:a844bbc2df033926de9f10ec34b5660a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">As takeSlice, but do a max-intensity projection across one axis.  <a href="#a844bbc2df033926de9f10ec34b5660a7"></a><br/></td></tr>
<tr class="memitem:a005a2c52dacaad46c4d156e645eb9b93"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a005a2c52dacaad46c4d156e645eb9b93">takeSliceFromData</a></td></tr>
<tr class="memdesc:a005a2c52dacaad46c4d156e645eb9b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a 2D slice of the given data in each wavelength.  <a href="#a005a2c52dacaad46c4d156e645eb9b93"></a><br/></td></tr>
<tr class="memitem:a4e2a72e86a469ee1defd202dadc32482"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a4e2a72e86a469ee1defd202dadc32482">mapCoords</a></td></tr>
<tr class="memdesc:a4e2a72e86a469ee1defd202dadc32482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse-transform the provided coordinates and use them to look up into the given array, to generate a transformed slice of the specified shape along the specified axes.  <a href="#a4e2a72e86a469ee1defd202dadc32482"></a><br/></td></tr>
<tr class="memitem:a63c95c99aae92c70d5044b52b0d3332e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a63c95c99aae92c70d5044b52b0d3332e">getValuesAt</a></td></tr>
<tr class="memdesc:a63c95c99aae92c70d5044b52b0d3332e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value for each wavelength at the specified TZYX coordinate, taking transforms into account.  <a href="#a63c95c99aae92c70d5044b52b0d3332e"></a><br/></td></tr>
<tr class="memitem:a3a60bc9f0a88a9d659c0989883a8447e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a3a60bc9f0a88a9d659c0989883a8447e">takeDefaultSlice</a></td></tr>
<tr class="memdesc:a3a60bc9f0a88a9d659c0989883a8447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a default slice through our view indices perpendicular to the given axes.  <a href="#a3a60bc9f0a88a9d659c0989883a8447e"></a><br/></td></tr>
<tr class="memitem:acc79c1fe999044772dc06efa97ca439c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#acc79c1fe999044772dc06efa97ca439c">getTransformationMatrices</a></td></tr>
<tr class="memdesc:acc79c1fe999044772dc06efa97ca439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a 4D transformation matrix based on self.alignParams for each wavelength.  <a href="#acc79c1fe999044772dc06efa97ca439c"></a><br/></td></tr>
<tr class="memitem:a35791259225a017cdcccebe98bfae328"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a35791259225a017cdcccebe98bfae328">hasZMotion</a></td></tr>
<tr class="memdesc:a35791259225a017cdcccebe98bfae328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is any Z motion in any wavelength's alignment parameters.  <a href="#a35791259225a017cdcccebe98bfae328"></a><br/></td></tr>
<tr class="memitem:acb2a7d5e30ec18a81d7e79c9511c329d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#acb2a7d5e30ec18a81d7e79c9511c329d">hasTransformation</a></td></tr>
<tr class="memdesc:acb2a7d5e30ec18a81d7e79c9511c329d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is any non-default transformation.  <a href="#acb2a7d5e30ec18a81d7e79c9511c329d"></a><br/></td></tr>
<tr class="memitem:a172a911869e30f297a93a6dfe36da7ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a172a911869e30f297a93a6dfe36da7ae">registerAlignmentCallback</a></td></tr>
<tr class="memdesc:a172a911869e30f297a93a6dfe36da7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback to be invoked when the alignment parameters change.  <a href="#a172a911869e30f297a93a6dfe36da7ae"></a><br/></td></tr>
<tr class="memitem:a2f49f13e2f467e41744f039c0105e6bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a2f49f13e2f467e41744f039c0105e6bc">setAlignParams</a></td></tr>
<tr class="memdesc:a2f49f13e2f467e41744f039c0105e6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the alignment parameters, then invoke our callbacks.  <a href="#a2f49f13e2f467e41744f039c0105e6bc"></a><br/></td></tr>
<tr class="memitem:a06d89f834ca84bb7d1d62b86dde3a03d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a06d89f834ca84bb7d1d62b86dde3a03d">getAlignParams</a></td></tr>
<tr class="memdesc:a06d89f834ca84bb7d1d62b86dde3a03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current alignment parameters for the specified wavelength.  <a href="#a06d89f834ca84bb7d1d62b86dde3a03d"></a><br/></td></tr>
<tr class="memitem:a48a270df11b3b3f1d644fc38c03033e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a48a270df11b3b3f1d644fc38c03033e1">alignAndCrop</a></td></tr>
<tr class="memdesc:a48a270df11b3b3f1d644fc38c03033e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply our alignment parameters to the data, then crop them, and either return the result for the specified wavelength(s), or save the result to the specified file path.  <a href="#a48a270df11b3b3f1d644fc38c03033e1"></a><br/></td></tr>
<tr class="memitem:a56a736523dd0e12a591060326ab5d076"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a56a736523dd0e12a591060326ab5d076">saveTo</a></td></tr>
<tr class="memdesc:a56a736523dd0e12a591060326ab5d076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just save our array to the specified file.  <a href="#a56a736523dd0e12a591060326ab5d076"></a><br/></td></tr>
<tr class="memitem:aea416aa826ddfaafc00ac2b94af42dbc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#aea416aa826ddfaafc00ac2b94af42dbc">getSliceSize</a></td></tr>
<tr class="memdesc:aea416aa826ddfaafc00ac2b94af42dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a slice in the specified dimensions.  <a href="#aea416aa826ddfaafc00ac2b94af42dbc"></a><br/></td></tr>
<tr class="memitem:a48c90433af255bf107d566f329729e99"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a48c90433af255bf107d566f329729e99">getSliceCoords</a></td></tr>
<tr class="memdesc:a48c90433af255bf107d566f329729e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mapping of axes to our view positions on those axes.  <a href="#a48c90433af255bf107d566f329729e99"></a><br/></td></tr>
<tr class="memitem:acaf86c2b053c35124f50f2d3f5012429"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#acaf86c2b053c35124f50f2d3f5012429">moveSliceLines</a></td></tr>
<tr class="memdesc:acaf86c2b053c35124f50f2d3f5012429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move self.curViewIndex by the specified amount, ensuring that we stay in-bounds.  <a href="#acaf86c2b053c35124f50f2d3f5012429"></a><br/></td></tr>
<tr class="memitem:ad41f8c6f64f887eb14230212ddd94af5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#ad41f8c6f64f887eb14230212ddd94af5">moveCropbox</a></td></tr>
<tr class="memdesc:ad41f8c6f64f887eb14230212ddd94af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the crop box by the specified amount, ensuring that we stay in-bounds.  <a href="#ad41f8c6f64f887eb14230212ddd94af5"></a><br/></td></tr>
<tr class="memitem:aa440c472e054c311328bebf80f561122"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#aa440c472e054c311328bebf80f561122">convertToMicrons</a></td></tr>
<tr class="memdesc:aa440c472e054c311328bebf80f561122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the given XYZ offsets by our pixel sizes to get offsets in microns.  <a href="#aa440c472e054c311328bebf80f561122"></a><br/></td></tr>
<tr class="memitem:ad35d84fec3554113997606ab79da41de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#ad35d84fec3554113997606ab79da41de">convertFromMicrons</a></td></tr>
<tr class="memdesc:ad35d84fec3554113997606ab79da41de"><td class="mdescLeft">&#160;</td><td class="mdescRight">As convertToMicrons, but in reverse.  <a href="#ad35d84fec3554113997606ab79da41de"></a><br/></td></tr>
<tr class="memitem:abe7051d25bdb15ba1b97bb5f5167d160"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#abe7051d25bdb15ba1b97bb5f5167d160">transformArray</a></td></tr>
<tr class="memdesc:abe7051d25bdb15ba1b97bb5f5167d160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a transformation to an input 3D array in ZYX order.  <a href="#abe7051d25bdb15ba1b97bb5f5167d160"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a063f806e5781b18444f7030cb9ad24d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a063f806e5781b18444f7030cb9ad24d9">image</a></td></tr>
<tr class="memdesc:a063f806e5781b18444f7030cb9ad24d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loaded MRC object.  <a href="#a063f806e5781b18444f7030cb9ad24d9"></a><br/></td></tr>
<tr class="memitem:a02643e0499237cfbba2e4331db8a6a1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a02643e0499237cfbba2e4331db8a6a1f">imageHeader</a></td></tr>
<tr class="memdesc:a02643e0499237cfbba2e4331db8a6a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header for the image data, which tells us e.g.  <a href="#a02643e0499237cfbba2e4331db8a6a1f"></a><br/></td></tr>
<tr class="memitem:a2bfa2479d08fe1a5f88d085e7a8edab1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a2bfa2479d08fe1a5f88d085e7a8edab1">filePath</a></td></tr>
<tr class="memdesc:a2bfa2479d08fe1a5f88d085e7a8edab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Location the file is saved on disk.  <a href="#a2bfa2479d08fe1a5f88d085e7a8edab1"></a><br/></td></tr>
<tr class="memitem:a170e5853453fc26b54f73421549e6bf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a170e5853453fc26b54f73421549e6bf9">numWavelengths</a></td></tr>
<tr class="memdesc:a170e5853453fc26b54f73421549e6bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of wavelengths in the array.  <a href="#a170e5853453fc26b54f73421549e6bf9"></a><br/></td></tr>
<tr class="memitem:ab2c6adea1130fe675bb9a3789a1db975"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#ab2c6adea1130fe675bb9a3789a1db975">size</a></td></tr>
<tr class="memdesc:ab2c6adea1130fe675bb9a3789a1db975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in pixels of the data, since having it as a Numpy array instead of a tuple (from self.imageArray.shape) is occasionally handy.  <a href="#ab2c6adea1130fe675bb9a3789a1db975"></a><br/></td></tr>
<tr class="memitem:ab7dbcdbb93114a936fa4e3760dd2c51b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#ab7dbcdbb93114a936fa4e3760dd2c51b">imageArray</a></td></tr>
<tr class="memdesc:ab7dbcdbb93114a936fa4e3760dd2c51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">5D array of pixel data, indexed as self.imageArray[wavelength][time][z][y][x] In other words, in WTZYX order.  <a href="#ab7dbcdbb93114a936fa4e3760dd2c51b"></a><br/></td></tr>
<tr class="memitem:a5afc27533b2a60835dccee667b6cc790"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a5afc27533b2a60835dccee667b6cc790">extendedHeaderFloats</a></td></tr>
<tr class="memdesc:a5afc27533b2a60835dccee667b6cc790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two arrays, one for ints, one for floats, for the extended header.  <a href="#a5afc27533b2a60835dccee667b6cc790"></a><br/></td></tr>
<tr class="memitem:ac416ae635c8816076ee060dbba5bb911"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#ac416ae635c8816076ee060dbba5bb911">dtype</a></td></tr>
<tr class="memdesc:ac416ae635c8816076ee060dbba5bb911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Datatype of our array.  <a href="#ac416ae635c8816076ee060dbba5bb911"></a><br/></td></tr>
<tr class="memitem:a9d4778206dd4273c604e6dfd83930137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a9d4778206dd4273c604e6dfd83930137">averages</a></td></tr>
<tr class="memdesc:a9d4778206dd4273c604e6dfd83930137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Averages for each wavelength, used to provide fill values when taking slices.  <a href="#a9d4778206dd4273c604e6dfd83930137"></a><br/></td></tr>
<tr class="memitem:aedb723abb08beee5c9de362a06200861"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#aedb723abb08beee5c9de362a06200861">cropMin</a></td></tr>
<tr class="memdesc:aedb723abb08beee5c9de362a06200861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower boundary of the cropped data.  <a href="#aedb723abb08beee5c9de362a06200861"></a><br/></td></tr>
<tr class="memitem:abcea9a4dcb832360e683ae56c36151af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#abcea9a4dcb832360e683ae56c36151af">cropMax</a></td></tr>
<tr class="memdesc:abcea9a4dcb832360e683ae56c36151af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper boundary of the cropped data.  <a href="#abcea9a4dcb832360e683ae56c36151af"></a><br/></td></tr>
<tr class="memitem:a9dd71755aacb5798e443411422d2fcda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a9dd71755aacb5798e443411422d2fcda">curViewIndex</a></td></tr>
<tr class="memdesc:a9dd71755aacb5798e443411422d2fcda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the single pixel that is visible in all different data views.  <a href="#a9dd71755aacb5798e443411422d2fcda"></a><br/></td></tr>
<tr class="memitem:a754a931dab540c0a53aa84d9c0a61f55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a754a931dab540c0a53aa84d9c0a61f55">alignParams</a></td></tr>
<tr class="memdesc:a754a931dab540c0a53aa84d9c0a61f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for transforming different wavelengths so they align with each other.  <a href="#a754a931dab540c0a53aa84d9c0a61f55"></a><br/></td></tr>
<tr class="memitem:a0407fe14ab1a1d4f389d4100d4fdc394"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1datadoc_1_1_data_doc.html#a0407fe14ab1a1d4f389d4100d4fdc394">alignCallbacks</a></td></tr>
<tr class="memdesc:a0407fe14ab1a1d4f389d4100d4fdc394"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of functions to call whenever the alignment parameters change.  <a href="#a0407fe14ab1a1d4f389d4100d4fdc394"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classutil_1_1datadoc_1_1_data_doc.html" title="The DataDoc class is, broadly, a wrapper around the Mrc module.">DataDoc</a> class is, broadly, a wrapper around the <a class="el" href="namespaceutil_1_1_mrc.html">Mrc</a> module. </p>
<p>When it loads a file, it loads all of the data in that file, and then makes it available as an array in WTZYX order (regardless of the order in which the data is stored in the MRC file). It additionally exposes some attributes of the MRC metadata, and provides functions for transforming and projecting the data array. </p>
</div><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a93299839c04fb9c720d8fb1994212ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filename</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiate the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the MRC file you want to load. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a48a270df11b3b3f1d644fc38c03033e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.alignAndCrop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wavelengths</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>timepoints</em> = <code>[]</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>savePath</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply our alignment parameters to the data, then crop them, and either return the result for the specified wavelength(s), or save the result to the specified file path. </p>
<p>If no wavelengths are specified, use them all. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd><p class="startdd">All of the logic dealing with the MRC file writing is basically copied from the old imdoc module, and I don't claim to understand why it does what it does. </p>
<p class="enddd">The extended header is not preserved. On the flip side, according to Eric we don't currently use the extended header anyway, so it was just wasting space. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad35d84fec3554113997606ab79da41de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.convertFromMicrons </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As convertToMicrons, but in reverse. </p>

</div>
</div>
<a class="anchor" id="aa440c472e054c311328bebf80f561122"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.convertToMicrons </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply the given XYZ offsets by our pixel sizes to get offsets in microns. </p>

</div>
</div>
<a class="anchor" id="a06d89f834ca84bb7d1d62b86dde3a03d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.getAlignParams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wavelength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current alignment parameters for the specified wavelength. </p>

</div>
</div>
<a class="anchor" id="a591da65bfccb09e8ed98ffebccae2e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.getImageArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the loaded MRC image data into a 5D array of pixel data in WTZYX order. </p>

</div>
</div>
<a class="anchor" id="a48c90433af255bf107d566f329729e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.getSliceCoords </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mapping of axes to our view positions on those axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>A list of axes, e.g. [0, 3] for (time, Y). If None, then operate on all axes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea416aa826ddfaafc00ac2b94af42dbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.getSliceSize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of a slice in the specified dimensions. </p>
<p>Dimensions are as ordered in self.size </p>

</div>
</div>
<a class="anchor" id="acc79c1fe999044772dc06efa97ca439c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.getTransformationMatrices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a 4D transformation matrix based on self.alignParams for each wavelength. </p>

</div>
</div>
<a class="anchor" id="a63c95c99aae92c70d5044b52b0d3332e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.getValuesAt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value for each wavelength at the specified TZYX coordinate, taking transforms into account. </p>
<p>Also return the transformed coordinates. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>This copies a fair amount of logic from self.mapCoords. </dd></dl>

</div>
</div>
<a class="anchor" id="acb2a7d5e30ec18a81d7e79c9511c329d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.hasTransformation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there is any non-default transformation. </p>

</div>
</div>
<a class="anchor" id="a35791259225a017cdcccebe98bfae328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.hasZMotion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there is any Z motion in any wavelength's alignment parameters. </p>

</div>
</div>
<a class="anchor" id="a4e2a72e86a469ee1defd202dadc32482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.mapCoords </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>targetCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>targetShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse-transform the provided coordinates and use them to look up into the given array, to generate a transformed slice of the specified shape along the specified axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A 5D array of pixel data (WTZYX) </td></tr>
    <tr><td class="paramname">targetCoords</td><td>4D array of WXYZ coordinates. </td></tr>
    <tr><td class="paramname">targetShape</td><td>Shape of the resulting slice. </td></tr>
    <tr><td class="paramname">axes</td><td>Axes the slice cuts along. </td></tr>
    <tr><td class="paramname">order</td><td>Spline order to use when mapping. Lower is faster but less accurate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad41f8c6f64f887eb14230212ddd94af5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.moveCropbox </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>isMin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the crop box by the specified amount, ensuring that we stay in-bounds. </p>

</div>
</div>
<a class="anchor" id="acaf86c2b053c35124f50f2d3f5012429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.moveSliceLines </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move self.curViewIndex by the specified amount, ensuring that we stay in-bounds. </p>

</div>
</div>
<a class="anchor" id="a172a911869e30f297a93a6dfe36da7ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.registerAlignmentCallback </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback to be invoked when the alignment parameters change. </p>

</div>
</div>
<a class="anchor" id="a56a736523dd0e12a591060326ab5d076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.saveTo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>savePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just save our array to the specified file. </p>

</div>
</div>
<a class="anchor" id="a2f49f13e2f467e41744f039c0105e6bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.setAlignParams </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wavelength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the alignment parameters, then invoke our callbacks. </p>

</div>
</div>
<a class="anchor" id="a3a60bc9f0a88a9d659c0989883a8447e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.takeDefaultSlice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>perpendicularAxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shouldTransform</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take a default slice through our view indices perpendicular to the given axes. </p>

</div>
</div>
<a class="anchor" id="a844bbc2df033926de9f10ec34b5660a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.takeProjectedSlice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>projectionAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shouldTransform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As takeSlice, but do a max-intensity projection across one axis. </p>
<p>This becomes impossible to do efficiently if we have rotation or scaling in a given wavelength, so we just have to transform the entire volume. It gets <em>really</em> expensive if we want to do projections across time with this... </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>We could be a bit more efficient here since only the wavelengths with nonzero rotation/scaling need to be transformed as volumes. </dd></dl>

</div>
</div>
<a class="anchor" id="a40a200657dd2bd774b38ce8a085073e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.takeSlice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shouldTransform</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passthrough to takeSliceFromData, using our normal array. </p>

</div>
</div>
<a class="anchor" id="a005a2c52dacaad46c4d156e645eb9b93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.takeSliceFromData </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shouldTransform</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a 2D slice of the given data in each wavelength. </p>
<p>Since the data is 5D (wavelength/time/Z/Y/X), there are three axes to be perpendicular to, one of which is always wavelength. The "axes" argument maps the other two axis indices to the coordinate the slice should pass through. E.g. passing in {1: 10, 2: 32} means to take a WXY slice at timepoint 10 through Z index 32. This was fairly complicated for me to figure out, since I'm not a scientific programmer, so I'm including my general process here:</p>
<ul>
<li>Figure out which axes the slice cuts across, and generate an array of the appropriate shape to hold the results.</li>
<li>Create an array of similar size augmented with a length-4 dimension. This array holds XYZ coordinates for each pixel in the slice; the 4th index holds a 1 (so that we can use a 4x4 affine transformation matrix to do rotation and offsets in the same pass). For example, an XY slice at Z = 5 would look something like this: [ [0, 0, 5] [0, 1, 5] [0, 2, 5] ... [ [1, 0, 5] ... [ [2, 0, 5] [ ... [</li>
<li>Subtract the XYZ center off of the coordinates so that when we apply the rotation transformation, it's done about the center of the dataset instead of the corner.</li>
<li>Multiply the inverse transformation matrix by the coordinates.</li>
<li>Add the center back on.</li>
<li>Chop off the dummy 1 coordinate, reorder to ZYX, and prepend the time dimension.</li>
<li>Pass the list of coordinates off to numpy.map_coordinates so it can look up actual pixel values.</li>
<li>Reshape the resulting array to match the slice shape. </li>
</ul>

</div>
</div>
<a class="anchor" id="abe7051d25bdb15ba1b97bb5f5167d160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def util.datadoc.DataDoc.transformArray </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zoom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a transformation to an input 3D array in ZYX order. </p>
<p>Angle rotates each slice, zoom scales each slice (i.e. neither is 3D). </p>

</div>
</div>
<h2>Member Data Documentation</h2>
<a class="anchor" id="a0407fe14ab1a1d4f389d4100d4fdc394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.alignCallbacks</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of functions to call whenever the alignment parameters change. </p>
<p>Each will be passed self.alignParams so it can take whatever action is necessary. </p>

</div>
</div>
<a class="anchor" id="a754a931dab540c0a53aa84d9c0a61f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.alignParams</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for transforming different wavelengths so they align with each other. </p>
<p>Order is dx, dy, dz, angle, zoom </p>

</div>
</div>
<a class="anchor" id="a9d4778206dd4273c604e6dfd83930137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.averages</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Averages for each wavelength, used to provide fill values when taking slices. </p>

</div>
</div>
<a class="anchor" id="abcea9a4dcb832360e683ae56c36151af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.cropMax</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upper boundary of the cropped data. </p>

</div>
</div>
<a class="anchor" id="aedb723abb08beee5c9de362a06200861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.cropMin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower boundary of the cropped data. </p>

</div>
</div>
<a class="anchor" id="a9dd71755aacb5798e443411422d2fcda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.curViewIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the single pixel that is visible in all different data views. </p>

</div>
</div>
<a class="anchor" id="ac416ae635c8816076ee060dbba5bb911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.dtype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Datatype of our array. </p>

</div>
</div>
<a class="anchor" id="a5afc27533b2a60835dccee667b6cc790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.extendedHeaderFloats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two arrays, one for ints, one for floats, for the extended header. </p>
<p>Indexed as self.extendedHeaderInts[wavelength, time, z, i] Either may be empty, depending on how big the extended header is. </p>

</div>
</div>
<a class="anchor" id="a2bfa2479d08fe1a5f88d085e7a8edab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.filePath</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Location the file is saved on disk. </p>

</div>
</div>
<a class="anchor" id="a063f806e5781b18444f7030cb9ad24d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.image</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loaded MRC object. </p>
<p>Note this is not just an array of pixels. </p>

</div>
</div>
<a class="anchor" id="ab7dbcdbb93114a936fa4e3760dd2c51b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.imageArray</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>5D array of pixel data, indexed as self.imageArray[wavelength][time][z][y][x] In other words, in WTZYX order. </p>
<p>In general we try to treat Z and time as "just another axis", but wavelength is dealt with specially. </p>

</div>
</div>
<a class="anchor" id="a02643e0499237cfbba2e4331db8a6a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.imageHeader</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Header for the image data, which tells us e.g. </p>
<p>what the ordering of X/Y/Z/time/wavelength is in the MRC file. </p>

</div>
</div>
<a class="anchor" id="a170e5853453fc26b54f73421549e6bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.numWavelengths</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of wavelengths in the array. </p>

</div>
</div>
<a class="anchor" id="ab2c6adea1130fe675bb9a3789a1db975"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util.datadoc.DataDoc.size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size in pixels of the data, since having it as a Numpy array instead of a tuple (from self.imageArray.shape) is occasionally handy. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>util/datadoc.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 3 2014 14:02:38 for OMX Cockpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
