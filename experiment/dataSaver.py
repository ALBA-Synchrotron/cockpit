import depot
import events
import util.datadoc
import util.logger
import util.threads

import numpy
import Queue
import threading
import time

## Unique ID for identifying saver instances
uniqueID = 0



## This class simply records all data received during an experiment and saves
# it to disk in MRC format.
class DataSaver:
    ## \param cameras List of CameraHandler instances for the cameras that
    #         will be generating images
    # \param numReps How many times the experiment will be repeated.
    # \param cameraToImagesPerRep Maps camera handlers to how many images to 
    #        expect for that camera in a single repeat of the experiment.
    # \param cameraToIgnoredImageIndices Maps camera handlers to indices of 
    #        images that we don't actually want to keep.
    # \param runThread Thread that is executing the experiment. When it exits,
    #        we know to stop expecting more images.
    # \param savePath Path to save the incoming data to.
    # \param pixelSizeZ Size of the Z "pixel" (i.e. distance between Z slices).
    # \param titles List of strings to insert into the MRC file's header.
    #        Per the file format, each string can be up to 80 characters long
    #        and there can be up to 10 of them. 
    def __init__(self, cameras, numReps, cameraToImagesPerRep, 
            cameraToIgnoredImageIndices, runThread,
            savePath, pixelSizeZ, titles):
        self.cameras = cameras
        self.numReps = numReps
        self.cameraToImagesPerRep = cameraToImagesPerRep
        self.cameraToIgnoredImageIndices = cameraToIgnoredImageIndices
        self.runThread = runThread
        global uniqueID
        ## Unique ID for our instance
        self.uniqueID = uniqueID
        uniqueID += 1
        # Find the maximum image size (in pixels) in X and Y. While we're at it,
        # assign a number to each camera, for indexing into our data array
        # later, and figure out how many images per camera we'll actually be 
        # *keeping*. 
        self.maxWidth, self.maxHeight = 0, 0
        ## We need to establish a consistent ordering for cameras so that
        # each image gets stored in the correct part of the file. This
        # maps camera handlers to indices.
        self.cameraToIndex = {}
        ## Maps camera handlers to total images kept per rep.
        self.cameraToImagesKeptPerRep = {}
        for i, camera in enumerate(self.cameras):
            width, height = camera.getImageSize()
            self.maxWidth = max(width, self.maxWidth)
            self.maxHeight = max(height, self.maxHeight)
            self.cameraToIndex[camera] = i
            self.cameraToImagesKeptPerRep[camera] = self.cameraToImagesPerRep[camera] - len(self.cameraToIgnoredImageIndices[camera])
        ## We need this for the upper bound on the array of data we write.
        self.maxImagesPerRep = max(self.cameraToImagesKeptPerRep.values())
        ## Maps ints to cameras; the ints represent the order in which the 
        # images are stored. 
        self.indexToCamera = dict([(value, key) for key, value in self.cameraToIndex.iteritems()])
        ## Timestamp of the first image we receive. 
        # We need this so we can rebase the timestamps of images to
        # to be relative to the beginning of the experiment -- Python 
        # timestamps can't be stored directly as 32-bit floating points without
        # losing a lot of precision. And we want to store image timestamps in
        # the extended header, to help us identify when frames get dropped.
        self.firstTimestamp = None

        ## Time at which we last received an image, so we know when images
        # have stopped arriving.
        self.lastImageTime = time.time()

        ## Filehandle we will write the data to.
        self.filehandle = open(savePath, 'wb')
        ## Lock on writing to the file.
        self.fileLock = threading.Lock()

        pixelSizeXY = depot.getHandlersOfType(depot.OBJECTIVE)[0].getPixelSize()
        drawer = depot.getHandlersOfType(depot.DRAWER)[0]
        wavelengths = [drawer.getWavelengthForCamera(c.name) for c in self.cameras]
        ## MRC header object for the data. 
        self.header = util.datadoc.makeHeaderForShape(
                (len(self.cameras), self.numReps, self.maxImagesPerRep, 
                    self.maxHeight, self.maxWidth),
                numpy.uint16, pixelSizeXY, pixelSizeZ, wavelengths)
        # By default, the headers generated by DataDoc are for files in ZWT order.
        # But for efficient saving of large multi-wavelength files, we need to store
        # in WZT order (where the cameras are as close together as possible).
        self.header.ImgSequence = 1
        # Write out the "titles" (metadata, like exposure settings)
        self.header.NumTitles = len(titles)
        self.header.title[:len(titles)] = titles
        ## Size of one image's worth of metadata in the extended header.
        # We store 1 4-byte float per image.
        self.extendedBytes = 4
        # Write the size of the extended header, in bytes. We'll be storing a 
        # timestamp for each image, as a 32-bit floating point value.
        self.header.next = self.extendedBytes * self.maxImagesPerRep * len(self.cameras) * self.numReps
        # Number of 32-bit floats in the extended header, per image.
        self.header.NumFloats = 1
        ## Offset in the file of the first image. The standard header takes
        # 1024 bytes; the rest is the extended header.
        self.headerOffset = 1024 + self.header.next

        ## Number of bytes to allocate for each image in the file.
        # \todo Assuming unsigned 16-bit integer here.
        self.imageBytes = (self.maxWidth * self.maxHeight * 2)

        # Write the header, to get us started. We will re-write this at the end when
        # we have more metadata to fill in.
        with self.fileLock:
            util.datadoc.writeMrcHeader(self.header, self.filehandle)
        
        ## List of how many images we've received, on a per-camera basis.
        self.imagesReceived = [0] * len(self.cameras)
        ## List of how many images we've written, on a per-camera basis.
        self.imagesKept = [0] * len(self.cameras)
        ## List of functions that receive image data and feed it into 
        # self.imagesReceived.
        self.lambdas = []
        ## List of (min, max) tuples, on a per-camera basis, tracking
        # the dimmest and brightest pixels.
        self.minMaxVals = []

        ## True if we should stop collecting data.
        self.shouldAbort = False
        ## True if we are done collecting data.
        self.amDone = False
        ## Queue of (camera index, image data, timestamp) tuples for images
        # that need to be saved
        self.imageQueue = Queue.Queue()

        # Use the names from the drawer, if available.
        names = []
        if depot.getHandlersOfType(depot.DRAWER):
            drawer = depot.getHandlersOfType(depot.DRAWER)[0]
            for camera in self.cameras:
                names.append(drawer.getDyeForCamera(camera.name))
        else:
            # Just use the camera names directly.
            names = [camera.name for camera in self.cameras]
        totals = []
        for camera in self.cameras:
            totals.append(self.cameraToImagesKeptPerRep[camera] * self.numReps)
        ## Thread that handles updating the UI.
        self.statusThread = StatusUpdateThread(names, totals)

        # Start the data-saving thread.
        self.saveData()
        

    ## Subscribe to the new-camera-image events for the cameras we care about.
    # Save the functions we generate for handling the subscriptions, so we can
    # unsubscribe later. Initialize self.minMaxVals. Start our status-update
    # thread.
    def startCollecting(self):
        for camera in self.cameras:
            func = lambda data, timestamp, camera = camera: self.onImage(self.cameraToIndex[camera], data, timestamp)
            self.lambdas.append(func)
            events.subscribe('new image %s' % camera.name, func)

            # \todo Assuming no value will ever be over 2**128, which ought
            # to be safe since our cameras are only 16-bit anyway.
            self.minMaxVals.append((2 ** 128, -(2 ** 128)))
        events.subscribe('user abort', self.onAbort)
        self.statusThread.start()


    ## User aborted; stop saving data.
    def onAbort(self):
        self.shouldAbort = True
        self.statusThread.shouldStop = True


    ## Wait for the runThread to finish, then wait a bit longer in case some
    # images are laggardly, before we close our filehandle.
    def executeAndSave(self):
        # Joining the thread doesn't actually work until it has started,
        # hence the delay here.
        time.sleep(.5)
        self.runThread.join()

        # Wait until it's been a bit without getting any more images in, or
        # until we have all the images we expected to get for each camera.
        while time.time() - self.lastImageTime < .5 or not self.imageQueue.empty():
            amDone = True
            for camera in self.cameras:
                total = self.imagesKept[self.cameraToIndex[camera]]
                target = self.cameraToImagesKeptPerRep[camera] * self.numReps
                if total != target:
                    # There exists a camera for which we do not have all
                    # images yet.
                    amDone = False
                    break
            if amDone or self.shouldAbort:
                break
            time.sleep(.01)
        self.amDone = True
            
        self.cleanup()

        # Determine min/max vals for each wavelength.
        for i in xrange(len(self.cameras)):
            # HACK: camera 1 is supposed to get min/max/median. However,
            # computing the median of a large dataset takes a very long time
            # (30s for a 2GB file on a fairly powerful computer), so we
            # just store 0.
            minVal, maxVal = self.minMaxVals[i]
            if i == 0:
                setattr(self.header, 'mmm1', (minVal, maxVal, 0))
            else:
                setattr(self.header, 'mm%d' % (i + 1), (minVal, maxVal))
        # Rewrite the header, now that we know what the min/max values are.
        with self.fileLock:
            util.datadoc.writeMrcHeader(self.header, self.filehandle)
        
        with self.fileLock:
            # Finish writing.
            self.filehandle.close()
            

    ## Clean up once saving is completed.
    def cleanup(self):
        self.statusThread.shouldStop = True
        for i, camera in enumerate(self.cameras):
            events.unsubscribe('new image %s' % camera.name, self.lambdas[i])
        events.unsubscribe('user abort', self.onAbort)
        

    ## Receive new data, and add it to the queue.
    def onImage(self, cameraIndex, imageData, timestamp):
        self.imageQueue.put((cameraIndex, imageData, timestamp))


    ## Continually poll our imageQueue and save data to the file.
    @util.threads.callInNewThread
    def saveData(self):
        while not self.amDone:
            if self.shouldAbort:
                # Do nothing.
                return
            cameraIndex, imageData, timestamp = self.imageQueue.get()
            if self.firstTimestamp is None:
                self.firstTimestamp = timestamp
            # Store the timestamp as a rebased 32-bit float; we can't use
            # 64-bit due to the file format restriction, and if we don't
            # rebase then the numbers are big enough that we lose decimal
            # precision.
            timestamp = timestamp - self.firstTimestamp
            with self.fileLock:
                self.writeImage(cameraIndex, imageData, timestamp)


    ## Write a single image to the file.
    def writeImage(self, cameraIndex, imageData, timestamp):
        self.imagesReceived[cameraIndex] += 1
        camera = self.indexToCamera[cameraIndex]
        # First determine if we actually want to keep this image.
        if self.imagesReceived[cameraIndex] % self.cameraToImagesPerRep[camera] in self.cameraToIgnoredImageIndices[camera]:
            # This image is one that should be discarded.
            return
        # Convert the timestamp into something we can cleanly write.
        timestamp = numpy.float32(timestamp)
        # Calculate the time and Z indices for the new image. This will in turn
        # help us to calculate the offset of the image in the file.
        numImages = self.imagesKept[cameraIndex]
        timepoint = int(numImages / self.maxImagesPerRep)
        zIndex = numImages % self.cameraToImagesKeptPerRep[camera]

        numCameras = len(self.cameras)
        # Index of the image into the 1D array of images we are effectively 
        # generating as we write data to the file. Note casting to long, since
        # these numbers can be big and by default Python doesn't always pick
        # the right type.
        imageOffset = long(timepoint * self.maxImagesPerRep * numCameras) + \
                (zIndex * numCameras) + cameraIndex
        
        height, width = imageData.shape

        # Pad with zeros. I wouldn't normally think this would be
        # necessary, but we get "invalid argument" errors when writing
        # to the filehandle if we don't.
        # \todo Figure out why this is necessary.
        paddedBuffer = numpy.zeros((self.maxHeight, self.maxWidth),
                dtype = numpy.uint16)
        paddedBuffer[:height, :width] = imageData

        # Seek to the appropriate byte offset for the timestamp; write
        # it; repeat for the image data.
        try:
            # Write the timestamp. 1024 is the size of the standard header.
            self.filehandle.seek(long(1024 + self.extendedBytes * imageOffset))
            self.filehandle.write(timestamp)

            # Write the image data.
            byteOffset = long(self.headerOffset + imageOffset * self.imageBytes)
            self.filehandle.seek(byteOffset)
            self.filehandle.write(paddedBuffer)
            self.imagesKept[cameraIndex] += 1
            self.lastImageTime = time.time()
            curMin, curMax = self.minMaxVals[cameraIndex]
            self.minMaxVals[cameraIndex] = (min(curMin, imageData.min()), max(curMax, imageData.max()))
        except Exception, e:
            print "Error writing image:",e
            raise e
            
        # Update the status text. But first, check for abort/experiment
        # completion, since we may actually be done now and we don't want
        # a misleading status text.
        if self.shouldAbort or self.amDone:
            return
        self.statusThread.newImage(cameraIndex)



## This thread handles telling the saving status light to update twice per
# second.
class StatusUpdateThread(threading.Thread):
    def __init__(self, cameraNames, totals):
        threading.Thread.__init__(self)
        ## List of names of the cameras.
        self.cameraNames = cameraNames
        ## List of images received per camera.
        self.imagesReceived = [0 for name in self.cameraNames]
        ## Lock on updating the above.
        self.imageCountLock = threading.Lock()
        ## List of total images expected per camera.
        self.totals = totals
        ## Set to True to end the thread.
        self.shouldStop = False


    def run(self):
        prevCounts = list(self.imagesReceived)
        self.updateText()
        while not self.shouldStop:
            if prevCounts != self.imagesReceived:
                # Have received new images since the last update; update the display.
                with self.imageCountLock:
                    self.updateText()
                    prevCounts = list(self.imagesReceived)
            else:
                # No images; wait a bit.
                time.sleep(.1)
        # Clear the status light.
        events.publish('update status light', 'image count', '',
                (170, 170, 170))


    ## Push a new text to the status light.
    def updateText(self):
        statusText = ''
        for i, name in enumerate(self.cameraNames):
            curCount = self.imagesReceived[i]
            maxCount = self.totals[i]
            statusText += '%s: %d/%d\n' % (name, curCount, maxCount)
        events.publish('update status light', 'image count', statusText,
                (255, 255, 0))


    ## Update our image count.
    def newImage(self, index):
        with self.imageCountLock:
            self.imagesReceived[index] += 1
            
        
